"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_manifest_plugin_1 = __importDefault(require("webpack-manifest-plugin"));
const createBabelLoader_1 = __importDefault(require("./loaders/createBabelLoader"));
const createFontLoader_1 = __importDefault(require("./loaders/createFontLoader"));
const plugins_1 = require("./plugins");
const utils_1 = require("./utils");
const getConfig_1 = __importDefault(require("./utils/getConfig"));
const getMode_1 = __importDefault(require("./utils/getMode"));
const paths_1 = require("./utils/paths");
// { production, development, mode, projectRoot }
function default_1(env, argv) {
    const { 
    /**
     * The project's `app.json`
     * This will be used to populate the `Constants.manifest` in the Unimodule `expo-constants`
     */
    expoConfig, 
    /**
     * **Dangerously** disable the default font loading configuration.
     * If you are merging `webpack.config.unimodules` with another less flexible config,
     * you may want to disable font loading in favor of a manually defined loader.
     *
     * If you do this, be sure to include `@expo/vector-icons` & `react-native-vector-icons`
     * otherwise icons won't work as expected.
     */
    supportsFontLoading = true, } = argv;
    const { platform = 'web' } = env;
    const config = expoConfig || getConfig_1.default(env);
    const locations = env.locations || paths_1.getPaths(env.projectRoot);
    const mode = getMode_1.default(env);
    const { build: buildConfig = {} } = config.web || {};
    const { babel: babelAppConfig = {} } = buildConfig;
    const babelProjectRoot = babelAppConfig.root || locations.root;
    const babelConfig = createBabelLoader_1.default({
        mode,
        platform,
        babelProjectRoot,
        verbose: babelAppConfig.verbose,
        include: babelAppConfig.include,
        use: babelAppConfig.use,
    });
    const { publicPath, publicUrl } = paths_1.getPublicPaths(env);
    const loaders = [
        {
            test: /\.html$/,
            use: ['html-loader'],
            exclude: locations.template.folder,
        },
        // Process application JS with Babel.
        babelConfig,
    ];
    if (supportsFontLoading) {
        const fontLoaderConfiguration = createFontLoader_1.default(locations.root, locations.includeModule);
        loaders.push(fontLoaderConfiguration);
    }
    return {
        // TODO: Bacon: It would be good not to define mode here. We currently need to for the env variables.
        mode,
        // configures where the build ends up
        output: {
            // This is the URL that app is served from.
            // We use "/" in development.
            publicPath,
        },
        plugins: [
            // Generate a manifest file which contains a mapping of all asset filenames
            // to their corresponding output file so that tools can pick it up without
            // having to parse `index.html`.
            new webpack_manifest_plugin_1.default({
                fileName: 'asset-manifest.json',
                publicPath,
            }),
            new plugins_1.ExpoDefinePlugin({
                mode,
                publicUrl,
                config,
                productionManifestPath: locations.production.manifest,
            }),
        ],
        module: {
            strictExportPresence: false,
            rules: loaders,
        },
        resolve: {
            symlinks: false,
            alias: utils_1.DEFAULT_ALIAS,
            extensions: utils_1.getModuleFileExtensions('web'),
        },
    };
}
exports.default = default_1;
//# sourceMappingURL=webpack.config.unimodules.js.map